<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Soft Exam</title>
    <meta name="description" content="Just Pass Exam like Coding ‘Hello World’.">
    
    
    <link rel="preload" href="/SoftExam/assets/css/8.styles.435c4bdd.css" as="style"><link rel="preload" href="/SoftExam/assets/js/app.c6ddcd87.js" as="script"><link rel="preload" href="/SoftExam/assets/js/2.d6a3fe48.js" as="script"><link rel="prefetch" href="/SoftExam/assets/js/5.9b89e5ff.js"><link rel="prefetch" href="/SoftExam/assets/js/1.c722b2ee.js"><link rel="prefetch" href="/SoftExam/assets/js/3.c0bc16d7.js"><link rel="prefetch" href="/SoftExam/assets/js/4.0932c78f.js"><link rel="prefetch" href="/SoftExam/assets/js/0.4ac990dc.js"><link rel="prefetch" href="/SoftExam/assets/js/6.7b6f3311.js"><link rel="prefetch" href="/SoftExam/assets/js/7.d6791866.js">
    <link rel="stylesheet" href="/SoftExam/assets/css/8.styles.435c4bdd.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/SoftExam/" class="home-link router-link-active"><!----><span class="site-name">
      Soft Exam
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="/SoftExam/" class="nav-link">Home</a></div><div class="nav-item"><a href="/SoftExam/SA/" class="nav-link router-link-active">系统分析师</a></div><div class="nav-item"><a href="https://github.com/RocherKong/SoftExam" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><!----></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/SoftExam/" class="nav-link">Home</a></div><div class="nav-item"><a href="/SoftExam/SA/" class="nav-link router-link-active">系统分析师</a></div><div class="nav-item"><a href="https://github.com/RocherKong/SoftExam" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><!----></nav><!----></div><div class="page"><div class="content"><p>对象的行为模式（描述类或对象如何交互及如何分配职责）</p><p>13 策略模式</p><p>即，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。</p><p>角色：环境角色、抽象策略角色和具体策略角色</p><p>应用场景：Java中的TreeSet(Comparator&lt;?Super E&gt; comparator) 和TreeMap(Comparator&lt;? Super K&gt; comparator)和会员折扣情形</p><p>14 模板方法模式</p><pre><code>即，一个设计师负责给出一个算法的轮廓和骨架，另一些设计师则负责给出这个算法的各个逻辑步骤。
</code></pre><p>角色：抽象模板角色（包含顶级逻辑组成的步骤、需要由子类实现的抽象方法声明、子类可选重写的方法、抽象模板自己的基本方法）、具体模板角色（包括需要实现父类的基本方法、父类中可选的重写方法）</p><p>关键：子类可以置换掉父类的可变部分，但是子类却不可以改变模板方法所代表的顶级逻辑</p><p>使用场景：银行不同的帐户的利率是不同的，可以利用该模式计算得到每种账户的利息。</p><p>15 观察者模式</p><p>即，定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个</p><p>主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p><p>角色：抽象主题角色（又叫做抽象被观察者角色）、具体主题角色（又叫做具体被观察者角色）、抽象观察者角色、具体观察者角色。</p><p>推模型</p><p>主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。</p><p>拉模型</p><p>主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。</p><p>例子：Java.util.Observable（被观察者需要继承的类，其中notifyObservers()方法会触发观察者的update()方法）、java.util.observer（观察者需要实现的）</p><p>16 迭代子模式</p><p>即，迭代子模式可以顺序地访问一个聚集中的元素而不必暴露聚集的内部表象。</p><p>角色：抽象迭代子角色、具体迭代子角色、聚集角色、具体聚集角色、客户端角色</p><p>白箱聚集与外禀迭代子</p><p>l  具体聚集角色向外界提供遍历方法</p><p>l  迭代子从外部控制聚集元素的迭代过程（控制的仅仅是一个游标而已）</p><p>黑箱聚集与内禀迭代子</p><p>l  同时保证聚集对象的封装和迭代子功能的实现</p><p>l  迭代子是聚集的内部类（private）</p><p>l  聚集不向外界提供访问自己内部元素的方法</p><p>主动迭代子和被动迭代子</p><p>静态迭代子和动态迭代子（failfast）</p><p>17 责任链模式</p><p>即，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。</p><p>角色：抽象处理者角色、具体处理者角色</p><p>应用场景：申请聚餐费用的管理</p><p>应用实例：责任链模式在Tomcat中的应用</p><p>缺点：（1）对于每一个请求都需要遍历职责链，性能是个问题；</p><p>（2）抽象处理者 AbstractHandler 类中的 handleRequest() 方法中使用了递归，栈空间的大小也是个问题。</p><p>18 命令模式</p><p>即，命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。</p><p>角色：客户端角色、命令角色、具体命令角色、请求者角色、接收者角色</p><p>客户端--请求--命令------具体命令接收者</p><p>优点：更松散的耦合、更动态的控制、很自然的复合命令、更好的扩展性</p><p>19 备忘录模式</p><p>即，备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。</p><p>角色：备忘录角色、发起人角色（创建备忘录）、负责人角色（保存备忘录）</p><p>“白箱”备忘录模式的实现（备忘录角色的内部所存储的状态对所有对象公开）</p><p>“黑箱”备忘录模式的实现（备忘录角色对发起人提供一个宽接口，而对其他对象提供一个窄接口）</p><p>多重检查点（备忘录模式可以将发起人对象的状态存储到备忘录对象里面，备忘录模式可以将发起人对象恢复到备忘录对象所存储的某一个检查点）</p><p>“自述历史”模式</p><p>20 状态模式</p><p>即，状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态的一个子类。</p><p>角色：环境角色、抽象状态角色、具体状态角色</p><p>功能：分离状态的行为，通过维护状态的变化，来调用不同状态对应的不同功能。即状态决定行为。</p><p>21 访问者模式</p><p>即，封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构则可以保持不变。</p><p>前提理解：静态分派（方法重载）和动态分派（方法继承）、实现双重分派的例子</p><p>角色：抽象访问者角色、具体访问者角色、抽象节点角色、具体节点角色、结构对象角色</p><p>双重分派：数据结构的每一个节点都可以接受一个访问者的调用，此节点向访问者对象传入节点对象，而访问者对象则反过来执行节点对象的操作。</p><p>优点：好的扩展性、好的复用性、分离无关行为</p><p>缺点：对象结构变化很困难，破坏封装</p><p>22 调停者模式</p><p>即，调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显引用。从而使它们可以较松散地耦合。当这些对象中的某些对象之间的相互作用发生改变时，不会立即影响到其他的一些对象之间的相互作用。从而保证这些相互作用可以彼此独立地变化。</p><p>角色：抽象调停者角色、具体调停者角色、抽象同事类角色、具体同事类角色</p><p>优点：松散耦合、集中控制交互、多对多变成一对多</p><p>缺点：过度集中化，交互多时会导致调停者对象变得十分复杂</p><p>23 解释器模式</p><p>即，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。</p><p>角色：抽象表达式角色、终结符表达式、非终结符表达式、环境角色</p></div><!----><!----></div></div></div>
    <script src="/SoftExam/assets/js/2.d6a3fe48.js" defer></script><script src="/SoftExam/assets/js/app.c6ddcd87.js" defer></script>
  </body>
</html>
